# 商品汇项目总结
## 一、开发一个Vue项目之前的准备  
### 安装与搭建
在进行项目开发之前，首先需要安装`Node`环境，还有`Webpack`以及将npm安装地址切换至淘宝镜像
> 如何切换淘宝镜像  
```
    // 查看镜像源使用状态
    npm get registry
    // 全局切换镜像源
    npm config set registry http://registry.npm.taobao.org/
```  
使用Vue-cli搭建一个项目
> 搭建项目指令  
```
    vue create hello-world
```
### 项目文件介绍
- **node_modules**：*项目依赖*
- **pubilc**：*一般放置静态资源（图片），需要注意，放在`pubilc`文件夹中的静态资源，`webpack`进行打包的时候，会原封不动打包到`dist`文件夹中*
- **src**：*放置程序员写的源代码*
    - **api**：*项目当中所有请求相关的文件*
    - **assets**：*一般也是放置静态资源（一般放置多个组件共用的静态资源），需要注意，放置在`assets`文件夹里面静态资源，在`webpack`打包的时候，`webpack`会把静态资源当做一个模块，打包进`JS`文件里面*
    - **components**：*一般放置的是非路由组件（常用的全局组件）*
    - **mock**：*用来保存使用`mock`模拟出来的`JSON`数据的文件夹*
    - **pages**：*路由组件文件夹*
    - **plugins**：*插件文件夹*
    - **router**：*路由配置文件夹，主要放置配置路由的文件*
    - **store**：*Vuex文件夹，存储数据*
    - **utils**：*存放工具类函数*
    - **App.vue**：*唯一的根组件，`Vue`当中的组件（`.vue`）*
    - **main.js**：*程序的入口文件，也是整个程序当中最先执行的文件*
- **babel.config.js**：*配置文件（`babel`相关）*
- **package.json**：*是项目的身份证，记录项目叫做什么名字，项目当中有哪些依赖、项目怎么运行*
- **package-lock.json**：*缓存性文件*  
### 配置Vue
1. 项目运行起来的时候，Vue会自动打开浏览器  
打开文件`package.json`，修改如下代码  
```JSON
"scripts": {
    "serve": "vue-cli-service serve --open",
    "build": "vue-cli-service build",
    "lint": "vue-cli-service lint"
  }
```  
2. eslint语法校验功能关闭  
没有关闭eslint语法校验会出现的语法报错：*声明变量但是并未使用*  
在根目录下创建`vue.config.js`文件，并且输入下面代码  
```javascript
module.exports = defineConfig({
    // 关闭eslint
    lintOnSave:false
)}
```  
3. src文件的简写方式  
给src文件夹配置一个别名，可以方便我们在后续的开发过程中输入路径，这里配置的别名为`@`，这样即使以后文件过多，也方便我们进行查找  
找到jsconfig.json文件，在里面添加如下代码  
```json
{
  "compilerOptions": {
    "target": "es5",
    "module": "esnext",
    "baseUrl": "./",
    "moduleResolution": "node",
    "paths": {
      "@/*": [
        "src/*"
      ]
    },
    "lib": [
      "esnext",
      "dom",
      "dom.iterable",
      "scripthost"
    ]
  },
  "exclude": ["node_modules","dist"]
}
```  
***
## 二、项目路由问题汇总
### 配置路由
在配置Vue路由之前，需要先安装Vue的路由组件，使用如下命令，安装Vue-router组件，<strong style="color:red">这里需要注意，vue2只能使用3版本的vue-router，所以在安装的时候需要进行版本限制</strong>  
```
    npm i --save vue-router@3
```  
安装完之后，对整个项目的路由进行一个分析。发现非路由组件主要有两个，*Home*和*Footer*，*Home*组件是在所有的组件中都需要显示的，但是*Footer*组件在登录页和注册页是不需要的  
在`router`文件夹中创建`index.js`文件，这个文件是整个项目配置路由的地方，并再次创建一个文件`routes.js`，用于管理所有的路由组件信息。然后要引入组件vue-router和一个Vue，在`index.js`文件中，引入组件并且创建一个vue-router的实例对象  
```javascript
    // 引入Vue
    import Vue from "vue";
    // 引入vue-router
    import VueRouter from "vue-router";
    // 引入组件之后需要使用组件
    Vue.use(VueRouter)
    // 引入routes
    import routes from './routes'
    // 配置路由
    let router = new VueRouter({
        // 配置路由
        routes,
        // 滚动行为
        scrollBehavior(to, from, savedPosition) {
        // 返回的y等于0，代表的是滚动条在最上方
            return { y: 0 }
        }
    })
    export default router
```
在以上代码中，除了之前说过的操作，还引入了之前创建的管理路由的文件，并将其注册在`router`实例当中，在`router`实例当中，可以配置滚动行为`scrollBehavior`，该属性配置的是路由发生跳转的时候，页面的位置处于什么地方  
最后一步就是在入口文件注册路由  
```javascript
    // 引入路由
    import router from '@/router'
    // 在Vue实例当中注册路由，
    new Vue({
    render: h => h(App),
    // 注册路由：底下的写法KV一致忽略V【router小写的】
    // 注册路由信息：当这里书写router的时候，组件身上都拥有$route、$router属性
    router,
}).$mount('#app')
```
> 路由组件与一般组件的区别？  
1. 路由组件一般是放置在`pages`或`views`文件夹，非路由组件一般放置在`compoents`文件夹中
2. 路由组件一般需要在`router`文件夹中进行注册（使用的即为组件的名字），非路由组件在使用的时候，一般都是以标签的形式使用的
3. 注册完路由，不管路由组件、还是非路由组件身上都有`$route`、`$router`属性
> \$route和$router  

- $route:一般是获取路由信息的(`url、query、params`等等)  
- $router:一般进行编程式导航进行路由跳转(`push或replace`)  
> 路由跳转的两种形式  

- 声明式导航`router-link`，可以进行路由的跳转
- 编程式导航`push`，可以进行路由的跳转，声明式导航能做的，编程式导航都能做，但是编程式导航除了可以进行路由跳转，还可以做一些其他的业务逻辑  

> 对Footer组件的隐藏  

    给Footer组件绑定v-show命令，我们可以根据组件身上的$route获取当前路由的信息，通过路由路径判断Footer显示与隐藏
### 进行二次封装push和replace  
> 首先了解一下push和replace的区别  
```
push方法可以接受一个对象参数，跳转到对应的路由，这个方法会向history栈添加一个记录，点击后退会返回到上一个页面  
replace参数同push一样，同样是跳转到指定的路由，但是这个方法不会向history里面添加新的记录，而是替代掉当前路由，点击返回，会跳转到上上一个页面  
```  
> 为什么要对push和replce进行二次开发  
```
    主要原因是因为：编程式路由跳转到当前路由（参数不变），多次执行会抛出NavigationDupLicated的警告错误，而声明式导航没有这类问题，所以对push和replace的二次开发，主要是为了不报错  
    错误出现的原因主要是因为最新的Vue-router引入了Promise，需要有成功的回调和失败的回调，才能让Promise正常运行  
    声明式导航没有报错的原因，是因为在底层已经处理过这个问题  
    如果不想进行二次开发可以通过给push方法传递相应的成功、失败的回调函数，可以捕获到当前的错误，避免弹出报错(如下代码)  
    但是这种写法治标不治本，在将来在别的组件当中push和replace，编程式导航还是会有类似的错误
```
```javascript
    this.$router.push({
        name: "search",
        params: {
          keyword: this.keyword,
        },
        query:{
          k:this.keyword.toUpperCase()
        },
    },
    ()=>{},
    ()=>{});
```
接下来在`index.js`文件中对push和replace进行二次封装，方便在项目的开发中使用  
```javascript
    // 先把VueRouter原型对象的push，先保存一下
    let originPush = VueRouter.prototype.push
    let originReplace = VueRouter.prototype.replace
    // 重写push|replace
    // 第一个参数：告诉原来push方法，你往哪里跳转（传递哪些参数）
    // 第二个参数：成功的回调
    // 第三个参数：失败的回调
    VueRouter.prototype.push = function (location, resolve, reject) {
        if (resolve && reject) {
            originPush.call(this, location, resolve, reject)
        } else {
            originPush.call(this, location, () => { }, () => { })
        }
    }
    VueRouter.prototype.replace = function (location, resolve, reject) {
        if (resolve && reject) {
            originReplace.call(this, location, resolve, reject)
        } else {
            originReplace.call(this, location, () => { }, () => { })
        }
    }
```  
> call和apply的区别  

- 相同点：都可以调用函数一次，都可以篡改函数上下文一次
- 不同点：call与apply传递参数，call传递参数可以用逗号隔开，apply方法执行，传递的是数组
### 注册路由组件
本项目所有的路由组件注册都在`routes.js`文件中进行的，一般注册组件的步骤为：引入组件，然后进行注册，但在今后的开发中，引入组件一般都会写入配置信息当中，以下以一个路由组件的注册为例  
```javascript
export default [
    {
        // 路由地址
        path: '/center',
        // 引入组件
        component: ()=>import("@/pages/Center"),
        // 路由名称
        name: 'center',
        // 路由元信息
        meta: {
            // 该属性配置是否展示Footer组件
            show: true
        },
        // 二级路由组件
        children: [
            {
                path: 'myorder',
                component: ()=>import("@/pages/MyOrder")
            },
            {
                path: 'grouporder',
                component: ()=>import("@/pages/Grouporder")
            }
        ]
    },
    // 重定向，在项目跑起来的时候，访问/，立马让他定向到首页
    {
        // 表示访问根页面的时候直接访问home路由
        path: '/',
        redirect: "/home"
    }
```  
配置路由的时候，可以给路由添加元信息`meta`，路由需要配置对象，它的`key`不能乱写，代码中的`show`用于`Footer`组件的展示或者隐藏。还有一个重定向属性，主要用于网站的时候，直接访问首页的路由，还有在有二级路由的时候，默认出现一个二级路由组件  
### 路由传参
> 路由传参的方式

- params参数：属于路径当中的一部分，需要注意，在配置路由的时候，需要占位
- query参数：不属于路径当中的一部分，类似ajax中的queryString /home?k=v&k=，不需要占位  
> 路由传参相关面试题  

1. 路由传递参数（对象写法）path是否可以结合params参数一起使用？  
    - *答：路由跳转传参的时候，对象的写法可以是`name`、`path`形式，但是需要注意的是，`path`这种写法不能与`params`参数一起使用*  
```javascript
    this.$router.push({
        path:'/search',
        params:{
          keyword:this.keyword
        },
        query:{
          k:this.keyword.toUpperCase()
        }
    })
```
2. 如何指定params参数可传可不传？
    - 比如：配置路由的时候，占位了（`params`参数），但是路由跳转的时候就不传递，路径会出现问题
    - 答：如何指定`params`参数可以传递、或者不传递，在配置路由的时候，在占位的后面加上一个`?`(`params`可以传递或者不传递)
```javascript
    this.$router.push({
        name:'search',
        query:{
          k:this.keyword.toUpperCase()
        }
    })
```
3. params参数可以传递也可以不传递，但是如果传递是空串，如何解决？  
    - 答：使用`undifined`解决：`parmas`参数可以传递、不传递（空的字符串）
```javascript
    this.$router.push({
        name:'search'||undefined,
        params:{
          keyword:''
        },
        query:{
          k:this.keyword.toUpperCase()
        }
    })
```
4. 路由组件能不能传递props数据？
    - 可以传递，有三种写法
```javascript
    if (this.$route.query) {
        let location = {
            name: "search",
            params: { keyword: this.keyword || undefined },
        };
        location.query = this.$route.query;
        this.$router.push(location);
    }
```  
### 导航守卫
vue-router 提供的导航守卫主要用来通过跳转或取消的方式守卫导航。这里有很多方式植入路由导航中：全局的，单个路由独享的，或者组件级的，在本项目中主要运用了全局路由守卫和独享路由守卫。*导航可以理解成为路由正在发生改变，进行路由跳转，而守卫表示的是守护需要跳转的路由的门卫，只有经过门卫的同意才能够进入该路由组件*  
可以使用在router文件下的index.js文件中建立一个全局前置守卫，在该项目中，运用了前置守卫进行了用户登录与未登录状态能否进入一些路由进行了限制  
```javascript  
    // 前置全局路由守卫
    router.beforeEach((to, from, next) => {
        
    }
```  
> 全局路由守卫的三个形参

- to：可以获取到你要跳转到哪个路由的信息
- from：可以获取到你从哪个路由来
- next：放行函数
    - next() 放行进入当前想要跳转的路由
    - next(path) 放行到指定的路由 
    - next(false) 回到之前来自的路由  

***
## 三、请求相关问题汇总
### 配置axios
> 为什么要对axios进行配置，而不是直接使用
```
    在该项目中，所有的请求路径都带有/api，在进行配置之后，可以在写请求的时候不用写/api，但是配置的主要原因是因为可以使用axios的请求拦截器和响应拦截器，它们的主要作用是在请求发出去之前和接收到服务器返回数据的时候进行一些业务处理
```  
在`api`文件当中，创建一个`request.js`文件，专门用来配置`axios`  
```javascript
    // 引入axios进行配置
    import axios from "axios";
    // 1.利用axios对象的方法create，去创建一个axios实例
    // 2.request就是axios，只不过可以稍微配置一下
    const requests = axios.create({
        // 配置对象
        // 基础路径，发送请求的时候，路径当中会出现api
        baseURL:"/api",
        // 代表请求超时的时间5秒
        timeout:5000
    })
    // 对外暴露
    export default requests
```  
配置完axios以后，创建另外一个文件夹`index.js`，专门用来管理项目中所有的请求，接口的统一管理并不是必须的，如果项目很小，完全可以在组件的生命周期发送请求    
```javascript
    // 引入配置的axios
    import requests from './request'
    // 以搜索模块的请求为例
    export const reqGetSearchInfo = (params) => {
        return requests({ url: '/list', method: 'post', data: params })
    }
```  
搜索模块给服务器发送请求的时候，需要传递参数，所以在声明请求函数的时候需要传递一个形参，用来接收参数  
### 跨域问题
由于浏览器的同源策略，在该项目中也存在跨域问题，在解决跨域之前，需要了解什么是跨域?  
```
    协议、域名、端口号不同请求，称之为跨域
```  
如何解决跨域呢？解决跨域的方式有很多，`JSONP、CROS、代理服务器`，在本项目中，运用的是vue中的代理服务器解决跨域，接下来就是配置代理服务器，在`vue.config.js`文件中进行代理服务器的配置  
```javascript
    module.exports = defineConfig({
        devServer:{
            proxy:{
                // 在之后调用接口的时候可以用api代替
                '/api':{
                    // 你想调用接口的域名和端口号
                    target:'http://39.98.123.211',
                }
            }
        }
    })
```  
### 请求拦截器和响应拦截器
请求拦截器主要是可以在请求发出去之前进行一些业务逻辑的处理，响应拦截器主要是可以在接收到服务器的数据返回的时候进行一些处理  
```javascript
    // 请求拦截器
    requests.interceptors.request.use((config)=>{
        // config：配置对象，对象里面有一个属性很重要，header请求头
        // 进度条开始动
        nprogress.start()
        return config
    })
// 响应拦截器
    requests.interceptors.response.use(
        (res)=>{
            // 成功的回调函数：服务器响应数据回来以后，响应拦截器可以检测到，可以做一些事情
            // 进度条结束
            nprogress.done()
            return res.data
        },
        (error)=>{
            // 响应失败的回调函数
            return Promise.reject(new Error('faile'))
        }
    )
```  
在发送请求的时候，可以添加一个进度条，能够知道发送请求的进度，进度条需要使用到`npm`包，首先需要下载这个包  
```
    npm i --save nprogress
```
下载完成之后就在axios配置文件中进行引入  
```javascript
    // 引入进度条
    import nprogress from "nprogress"
    // start：进度条开始 done：进度条结束
    // 引入进度条样式
    import "nprogress/nprogress.css"
```  
并在请求拦截器和响应拦截器中进行配置，如上拦截器代码中所示  
### mock
`mock`是前端开发中专门用来模拟数据的一个插件，有时候前端开发的过程中，后端接口没有开发完毕，导致前端无法工作，所以可以借助`mock`来模拟一些数据，进行前端页面的数据展示  
使用`mock`的第一步是安装`mock`这个插件  
```
    npm i --save mockjs
```  
在`mock`文件夹里面创建一个`mockServe`配置文件，用来管理和配置数据文件。将准备好的`json`数据文件直接放入`mock`文件夹中，然后再`mockServe`中进行引入，然后配置`mock`数据的请求地址，以及将刚刚引入的`json`数据传递出去，之后重新配置一个axios文件，专门用于请求mock的数据，请求的方式和使用axios一模一样。
```javascript
    // 先引入mockjs模块
    import Mock from 'mockjs'
    import banner from './banner.json'
    // mock数据：第一个参数请求地址，第二个参数：请求数据
    Mock.mock("/mock/banner",{code:200,data:banner})//模拟首页大的轮播图的数据
```  
但是不要忘记<strong style="color:red">需要在入口文件引入mockServe</strong>，采用直接引入就可以  
```javascript
    import "@/mock/mockServe"
```
***
## 四、Vuex相关问题汇总
### 什么是Vuex
`vuex`是官方提供一个插件，状态管理库，集中式管理项目中组件共用的数据。切记，并不是全部项目都需要`vuex`，如果项目很小，完全不需要`vuex`，如果项目很大，组件很多，数据维护很费劲  
安装Vuex  
```
    npm i --save vuex
```  
Vuex相关的所有文件都在`store`文件夹中，在该文件夹中进行`vuex`仓库的管理和配置  
在`store`文件夹中创建一个`index.js`专门用来配置`vuex`  
```javascript
    // 引入vue
    import Vue from "vue";
    // 引入vuex
    import Vuex from "vuex"
    // 使用vuex插件
    Vue.use(Vuex)
    // 引入小仓库 
    import home from './home'
    // 对外暴露Store类的一个实例
    export default new Vuex.Store({
    // 实现Vuex仓库模块开发存储数据
        modules:{
            home
        }
    })
```  
这就配置完成`vuex`，配置完成之后也需要在入口文件`main.js`中进行*vuex仓库的引入和注册*
```javascript
    // 引入仓库
    import store from '@/store'
    // 在Vue实例当中注册仓库，
    new Vue({
    render: h => h(App),
    // 注册仓库：组件实例的身上会多了一个属性$store属性
    store
}).$mount('#app')
```  
使用vuex主要是为了能够使用vuex进行模块化开发，所以可以将各组件的数据进行分类管理，在store文件夹下面建立不同组件所需要的仓库进行数据的管理，然后通过ES6引入模块的方式，将各个小仓库引入index.js配置文件当中，从而实现模块化的vuex开发。  
在项目开发的过程中，发请求的部分，都是在actions中进行的，当actions接收到服务器传递来的数据之后，如果需要保存服务器传递来的数据，就将数据传递给mutations通知state进行存储。如果不需要保存属性，一般直接向组件内传递成功的Promise结果，然后组件再进行一些操作  
```javascript
    // 引入请求
    import { reqCategoryList } from '@/api'
    // home模块的小仓库
    const state = {
        // state中的默认初始值别瞎写，服务器返回是对象，服务器返回是数组【根据接口返回值初始化的】
        categoryList: [],
    }
    const mutations = {
        CATEGORYLIST(state, categoryList) {
            state.categoryList = categoryList
        }
    }
    const actions = {
        // 通过api里面的接口函数调用，向服务器发请求，获取服务器的数据
        async categoryList({ commit }) {
            let result = await reqCategoryList()
            if (result.code == 200) {
                commit('CATEGORYLIST', result.data)
            }
        }
    }
    // 计算属性
    const getters = {}
    export default {
        state,
        mutations,
        actions,
        getters
    }
```  
getters计算属性的主要作用就是为了简化数据，方便在组件中的读取或者使用  
***
## 五、非路由组件开发问题汇总
### Header组件
> 开发组件的步骤  

    1. 书写静态页面（HTML+CSS）  
    2. 拆分组件  
    3. 获取服务器的数据动态展示  
    4. 完成相应的动态业务逻辑  
组件的主要组成由*组件的结构、组件的样式、组件的静态资源*，在我们的项目开发过程中，使用的`css`样式是`less`构成的，但是浏览器是不认识`less`的，所以需要安装一下`less`相关的`npm`包，把`less`解析成`css`  
```
    npm i --save less-loader@5
```  
安装完成之后需要在组件内的样式标签内进行配置，这样就能将less代码解析成css代码  
```javascript
    <style scoped lang="less">
```  
> 使用组件的步骤

    1.创建或定义好一个组件
    2.引入组件
    3.注册组件  
*Header组件和Footer组件都是在App.js当中进行引入和注册的*
#### Header组件主要逻辑业务分析
> 搜索传递keyword关键字

在`Header`组件当中，最主要的业务逻辑就是通过`input`框向`Search`组件传递数据，使用的传递方式是携带`params`参数的对象写法进行传递，使用`params`传参需要在配置路由的时候，使用`:`占位  
具体实现步骤：  
1.  给`input`进行`v-model`数据双向绑定，保证能获取到`input`的内容
2.  给搜索按钮绑定一个点击事件，点击之后发送请求
3.  在`methods`中为点击事件配置方法  
```javascript
    goSearch() {
        if (this.$route.query) {
            let location = {
                name: "search",
                params: { keyword: this.keyword || undefined },
            };
            location.query = this.$route.query;
            this.$router.push(location);
        }
    }
```   
**注意事项**
```
1. 为什么在传递params参数的时候后面有一个或undefined
    - 因为在传递给Search组件params参数的时候，至少要传递一个空的数组，如果不传递会导致解析的时候出现问题，所以这里如果input框中有输入则传递input框中输入的keyword，如果没有输入keyword则传递undefined会更好
2. location.query是什么意思
    - 在点击搜索按钮传递参数的时候，如果有query参数，可以将query参数一同携带
```
### TypeNav组件
该组件是一个全局组件，全局组件的使用和别的组件都不一样  
> 如何使用全局组件

全局组件静态写好之后需要在入口文件`main`中进行引入和注册，这样整个项目的所有路由中都可以使用这个组件
```javascript
    // 引入组件
    import TypeNav from '@/components/TypeNav'
    // 第一个参数：全局组件的名字 第二个参数：哪一个组件
    Vue.component(TypeNav.name, TypeNav)
```  
#### TypeNav组件主要逻辑业务分析
> 动态数据的展示
```
    因为TypeNav组件是一个全局组件，而且需要动态展示数据，所以必须要向服务器发请求获得数据，考虑到性能问题，只发一次请求即可，因为App组件只会挂载一次，所以应该在App组件中派发action，通知向服务器获取数据。如果不在App组件中派发action，则需要每次都在TypeNav组件挂载的时候向服务器获取数据，不是性能的表现
```  
```javascript
    mounted() {
    // 通知vuex发请求，获取数据，存储于仓库当中
    // 派发一个action||获取商品分类的三级列表数据
    this.$store.dispatch("categoryList");
```  
派发完`action`以后，应该在`store`仓库中接收这个请求，然后在`actions`发送`axios`请求，上面的`vuex`代码就是`TypeNav`的仓库示例  
当仓库获取到数据并存储完毕之后，组件就应该向仓库索要数据并在组件上使用，这时候就需要用到`mapState`和`mapGetters`向仓库获取数据，在组件中引入，然后在`computed`中获取数据  
```javascript
    import { mapState } from "vuex";
    computed: {
        ...mapState({
        // 右侧需要的是一个函数，当使用这个计算属性的时候，右侧函数会立即执行一次
        // 注入一个参数state，其实即为大仓库中的数据
        categoryList: (state) => state.home.categoryList,
        }),
    }
```  
组件获取到的所有数据都在该计算属性里，可以在模板内使用`{{}}`进行插入展示数据  
> 点击各分类后跳转Search路由并传递参数  

三级联动用户可以点击一级分类、二级分类、三级分类，当用户点击的时候，会从`home`路由跳转到`search`路由，以及会把用户选中的产品(产品的ID、产品的名字)，在路由跳转的时候，一起传递
**注意事项**  
三级联动跳转如果使用声明式导航`router-link`，是可以实现路由的跳转与传递参数，但是需要注意，会出现卡顿的现象。主要是因为`router-link`是一个组件，当服务器的数据返回之后，循环出很多的`router-link`组件(创建组件实例)，创建组件实例的时候，一瞬间加载很多组件是很耗内存的，因此出现了卡顿现象，所以该项目采用的是事件的委派+编程式导航进行跳转  
但是利用事件的委派，又会产生几个问题
1. 把全部的子节点(h3、dt、dl、em)的事件委派给父亲节点
2. 点击a标签的时候，才会进行路由跳转(怎么能确定点击的一定是a标签)
3. 存在另外一个问题，即使你能确定点击的是a标签，如何区分是一级、二级、三级分类的标签
所有接下来就是解决这几个问题  
把子节点当中a标签，加上自定义属性data-categoryName，其余的子节点是没有的，以下实例的是二级菜单    
```html
    <a :data-categoryName="c2.categoryName" :data-category2Id="c2.categoryId">{{ c2.categoryName }}</a>
```  
为父节点绑定一个点击事件`goSearch`，并在`methods`中进行配置，节点中有一个属性方法`dataset`，可以获取到节点的自定义属性和属性值  
```javascript
    // 首先接收触发这个事件的全部节点
    let element = event.target;
    // 提取带有data-categoryName这样节点
    let { categoryname, category1id, category2id, category3id } = element.dataset;
```  
这样就能够确定我们获取到的节点一定是`a`标签，一二三级分类标签的区分也能够通过`category1id,category2id,category3id`进行区分  
所以接下来就可以将用户点击的参数打包并发送给Search路由，在路由跳转的时候，如果带有params参数，可以一同捎带过去    
```javascript
    // 如果标签身上拥有categoryName一定是a标签
    if (categoryname) {
        // 整理路由跳转的参数
        let location = { name: "search" };
        let query = { categoryName: categoryname };
        // 一级分类、二级分类、三级分类的a标签
        if (category1id) {
          query.category1Id = category1id;
        } else if (category2id) {
          query.category2Id = category2id;
        } else {
          query.category3Id = category3id;
        }
        // 判断：如果路由跳转的时候，带有params参数，捎带脚传递过去
        if(this.$route.params){
          location.params=this.$route.params
        }
        // 整理完参数
        location.query = query;
        // 路由跳转
        this.$router.push(location);
    }
```  
> 用JS逻辑来实现一级菜单的鼠标移入背景颜色  

首先需要写好带有背景颜色的`css`，在data中创建一个变量`currentIndex`并赋值为`-1`，然后给容器绑定一个动态的`class`，并且增加判断条件，然后给内层容器绑定了一个鼠标移入事件，并且传递参数index    
```html
    <div class="item" v-for="(c1, index) in categoryList" :key="c1.categoryId" :class="{ cur: currentIndex == index }">
        <h3 @mouseenter="changeIndex(index)">
```  
在`methods`中配置鼠标移入事件`changeIndex`，并且还需要传递`index`值，将`data`中的`currentIndex`的值变为分类元素的索引值，这样刚才的判定条件就会生效，在`div`中就会出现`cur`这个`class`属性  
```javascript
    // 鼠标进入修改响应式数据currentIndex属性
    changeIndex(index){
        // index:鼠标移上某一个一级分类的元素的索引值
        this.currentIndex = index;
    }
```  
鼠标移出事件也同理，给外层容器绑定一个`@mouseleave`鼠标移出事件，然后将`currentIndex`的值改为`-1`即可  
> 用JS逻辑来实现移入一级菜单，弹出二三级菜单

首先给二三级菜单的外层容器绑定一个动态的`class`  
```html
    <div class="item-list clearfix" :style="{ display: currentIndex == index ? 'block' : 'none' }">
```  
因为之前已经有过鼠标移入增加背景颜色的响应函数，所以这里的`currentIndex`会根据那个函数进行变化，这里不需要过多的书写代码  
> TypeNav中的一级菜单的隐藏和显示  

`TypeNav`中的一级菜单在`home`路由当中是展示的状态，但是在其他路由组件中，是鼠标移入的时候才出现，所以需要用到条件渲染`v-show`，判断当前路由是否是在`home`路由下，在此之前，我们先需要定义一个`flag`，在`data`中定义一个变量`show`，值为`true`，默认情况下，我们让一级菜单处于展开的状态  
当组件挂载完毕之后，就需要对当前的路由进行判断了，如果不是home路由，那么就不应该展示一级菜单，所以应该在声明周期中进行一个判断  
```javascript
    mounted() {
        // 当组件挂载完毕，需要进行一次判断
        // 如果不是Home路由组件，将typeNav进行隐藏
        if (this.$route.path != "/home") {
            this.show = false;
        }
    }
```  
利用事件的委派，给外层容器绑定了鼠标移入和移出事件  
```html
    <div @mouseleave="leaveIndex" @mouseenter="enterShow">
```  
当鼠标移入菜单的时候，需要进行判断，如果当前的路由不是home，就应该让菜单进行显示，反之移出隐藏也是一样  
```javascript
    // 一级分类鼠标移出的事件回调
    leaveIndex() {
        // 鼠标移出currentIndex，变成-1
        this.currentIndex = -1;
        // 当鼠标离开的时候，让商品分类列表进行隐藏
        if (this.$route.path != "/home") {
        this.show = false;
      }
    },
    // 一级分类鼠标移入的事件回调
    enterShow() {
        if (this.$route.path != "/home") {
            this.show = true;
        }
    }
```  
> 一级分类菜单的动画效果

需要执行过渡动画的部分，需要用`<transition>`包裹起来，最好携带一个名字`<transition name="sort">`，然后在css中书写代码  
**注意事项**  
要想使用过渡动画，前提元素或者组件内必须要有`v-if`或者`v-show`条件渲染才能触发动画 
```less
    // 过度动画的样式
    // 过度动画开始的状态（进入）
    .sort-enter{
      height: 0px;
    }
    // 过度动画的结束状态（进入）
    .sort-enter-to{
      height: 461px;
    }
    // 定义动画的时间、速率
    .sort-enter-active{
      transition: all .5s linear;
    }
```  
> 节流和防抖的运用

在该组件中，鼠标移入一级菜单展示背景颜色的地方可以运用一下节流，但是首先需要了解什么是节流和防抖  
- 正常来说，事件触发非常频繁，而且每一次的触发，回调函数都要去执行（如果时间很短，而回调函数内部有计算，那么很有可能出现浏览器卡顿）
- 节流：在规定的间隔时间范围内不会重复触发回调，只有大于这个时间间隔才会触发回调，把频繁触发变为少量触发
- 防抖：前面的所有的触发都被取消，最后一次执行在规定的时间之后才会触发，也就是说如果连续快速的触发 只会执行一次  
如果想手写一个节流和防抖，必须要掌握`闭包`和`延迟器`，在我们的项目中，直接运用了别人封装好的节流和防抖包`lodash`  
```
    npm i --save lodash
```  
因为该包我们只用其中的节流`(throttle)`和防抖`(debounce)`，所以没有必要全部引入，只需要引入其中的节流文件即可  
```javascript
    import throttle from "lodash/throttle";
    methods: {
        // 鼠标进入修改响应式数据currentIndex属性
        // throttle回调函数别用箭头函数，可能出现上下文this问题
        changeIndex: throttle(function (index) {
            // index:鼠标移上某一个一级分类的元素的索引值
            // 正常情况（用户慢慢的操作）：鼠标进入，每一个一级分类h3，都会触发鼠标进入事件
            // 非正常情况（用户操作很快）：本身全部的一级分类都应该触发鼠标进入事件，但是经过测试，只有部分h3触发了
            // 就是由于用户行为过快，导致浏览器反应不过来，如果当前回调函数中有一些大量业务，有可能出现卡顿现象
            this.currentIndex = index;
        }, 50)
    }
```  
引入完毕之后，对之前的`changeIndex`进行修改，改为50毫秒触发一次，这样就完成了节流的效果  
### Carousel组件
该组件是轮播图逻辑组件，也是一个全局组件，项目中的轮播图都使用插件`swiper`来实现，所以先要来安装一下这个插件  
```
    npm i --save swiper@5
```  
swiper使用的步骤  
1. 引入相应的依赖包  
2. 保证页面中的结构一定要有  
3. 初始化swiper实例，给轮播图添加动态效果  

我们将swiper的样式文件在main.js文件中进行引入，这样全局使用这个组件的都可以使用到这个样式，而不用重复引用  
```javascript
    // 引入swiper样式
    import 'swiper/css/swiper.css'
```
#### Carousel组件主要逻辑业务分析
> 在保证页面渲染完成并实现轮播图

初始化`swiper`实例如果在`mounted`生命周期中执行，会出现问题，因为当`vue`渲染`dom`并挂载完毕的时候，向服务器发请求的数据还未存储于仓库中，导致页面的结构还不完整，所以`swiper`就无法正常工作，所以正确的解决方案应该是**watch+$nextTick**  
**nextTick的解释**  
```
    在下次DOM更新循环结束之后执行延迟回调，在修改数据之后立即使用这个方法，获取更新后的DOM  
    $nextTick可以保证页面中的结构一定是有的，经常和很多插件一起使用，因为都需要DOM已经存在了
```  
```javascript
    watch: {
        list: {
        // 为什么watch监听不到list：因为这个数据从来没有发生过变化（数据是父亲给的，父亲给的就是一个对象，对象里该有的数据都是有的）
        // 立即监听：不管有没有数据，上来立即监听一次
        immediate: true,
        handler(newValue, oldValue) {
            // 只能监听到数据已经有了，但是v-for动态渲染结构我们还是没有办法确定的，因此还是需要nextTick
            this.$nextTick(() => {
            var mySwiper = new Swiper(this.$refs.floor1Swiper, {
                // direction: 'vertical', // 垂直切换选项
                loop: true, // 循环模式选项
                autoplay: {
                delay: 3000,
                disableOnInteraction: false,
                },

                // 如果需要分页器
                pagination: {
                el: ".swiper-pagination",
                clickable: true,
                },

                // 如果需要前进后退按钮
                navigation: {
                nextEl: ".swiper-button-next",
                prevEl: ".swiper-button-prev",
                },
            });
            });
        },
        },
    },
```  
具体的swiper使用可以参考swiper[官方文档](https://www.swiper.com.cn/)
### Pagination组件
分页器组件是一个全局组件，主要运用在`search`路由和`center`路由组件当中，首先需要了解为什么很多项目中需要使用分页器，它的作用到底是什么。在一些项目当中同时需要展示的数据有很多，如果进行一次性的渲染会导致浏览器卡顿，影响用户体验  
在封装分页器之前，还需要了解分页器的基本实现原理。分页器的展示需要四个数据  
```
    pageNo：代表当前是第几页  
    pageSize：代表每一页展示多少条数据  
    total：代表整个分页一共要展示多少条数据  
    continues：代表分页连续页码个数，一般都是奇数5或者7，因为奇数对此，比较美观  
    通过pageSize和total可以知道一个隐藏的条件就是一共需要多少页，注意页数需要向上取整
```  
对于一个分页器而言，最重要的部分就是算出连续页面的起始数字和结束数字。下面来开始进行开发，首先要制造几个假数据来进行开发，自己创建上述的四个数据来进行开发。例如  
```
    pageNo:1
    pageSize:3
    total:278
    continues:5
```  
首先可以直接填入模板中的数据有total，表示整个分页所有的数据总共有多少条，可以通过计算属性，计算出一共需要多少页  
```javascript
    computed: {
        // 计算总共多少页
        totalPage() {
            // 向上取整
            return Math.ceil(this.total / this.pageSize);
        },
    }
```  
下面计算出连续页码的起始页码和结束页码  
```javascript
    computed: {
        // 计算出连续的页码的起始数字和结束数字[连续的页码数：至少是5]
        starNumAndEndNum() {
        const { continues, pageNo, totalPage } = this;
        // 先定义两个变量存储起始数字和结束数字
        let start = 0,
            end = 0;
        // 连续页码数字5【至少5页】，如果出现不正常的现象【就是不够5页】
        // 不正常现象【总页数没有连续页码多】
        if (continues > totalPage) {
            start = 1;
            end = totalPage;
        } else {
            // 正常现象【连续的页码5，但是你的总页数一定是大于5的】
            // 起始数字
            start = pageNo - parseInt(continues / 2);
            // 结束数字
            end = pageNo + parseInt(continues / 2);
            // 把出现不正常的现象【start数字出现0|负数】纠正
            if (start < 1) {
            start = 1;
            end = continues;
            }
            // 把出现不正常的现象【end数字大于总页面】纠正
            if (end > totalPage) {
            start = totalPage - continues + 1;
            end = totalPage;
            }
        }
        return { start, end };
        },
    }
```  
首先在`computed`计算属性里面定义一个函数，用来计算连续页码的开始与结束页码。为了方便之后的书写，在代码最上方先对需要用到的变量进行了解构，然后定义了两个变量用来存储开始的页码和结束的页码，并且要将这两个变量进行返回。接下来就是考虑一些问题，我们定义了一个值叫做`continues`，表示页码的连续个数，这里我们给它了一个值是`5`，但是会出现一些情况，总页数没有连续页码多，所以我们就要进行判断，当连续页码数`continues`大于总页数`totalPage`的时候，直接将起始值`start`赋值为`1`，结束值赋值为总页数。如果不满住刚刚的`if`条件，那么剩下的就是总页码大于`5`的情况，然后就可以通过计算，计算出起始页。  
因为已经知道了当前的页码，所以可以用当前页码减去`2`就能知道开始页码，但是考虑该组件是一个封装组件，所以应该考虑之后的运用形式，比如连续页码为**3个、7个*等，可以灵活的进行变化，所以这里用`parseInt(continues/2)`来表示连续*5页码需要减去的3*，将来`continues`的值变换这里也能跟着一起变化，同理可以计算出结束`end`的值。  
但是就会产生另外一个问题，当前页为`2`和`1`的时候，开始值会变成`0或者负数`，所以要限制开始值的最小值，当出现开始值小于`1`的时候，应该限制起始值，直接`等于1`，最大值就等于`continues  `
同理，对结束的数字也要进行限制，不能大于总页数，所以如果结束数字出现大于总页数的情况，应该把结束数字限制为总页数`totalPage`，开始页数就是最大总页数减去连续页码数加`1`  
中间的连续页码应该采用`v-for`遍历的形式进行展示  
```javascript
    <button v-for="(page, index) in starNumAndEndNum.end" :key="index" 
        v-show="page >= starNumAndEndNum.start"
        @click="$emit('getPageNo', page)"
        :class="{active:pageNo==page}"
        >{{ page }}</button>
```  
`v-for是`可以进行遍历数字的，所以遍历的就是刚刚计算的结束值，但是要增加一个渲染条件，只显示从起始值开始的数字。  
分页器当中的按钮都是有限制条件的  
```javascript
    <button :disabled="pageNo == 1" @click="$emit('getPageNo', pageNo - 1)">
      上一页
    </button>
```  
在上一页按钮当中，当前值为`1`的时候，按钮将变得不可用，同理下一页的时候，当按钮为总页数的时候，按钮变得不可用。  
分页器当中的省略号也是有限制条件的  
```javascript
    // 开始的省略号
    <button v-if="starNumAndEndNum.start > 2">···</button>
    // 结束的省略号
    <button v-if="starNumAndEndNum.end < totalPage - 1">···</button>
```  
在开始的省略号当中，开始值应该大于`2`的时候才显示出省略号，因为`1···34567`，中间`2`开始才能被省略。同理结束的省略号，应该小于总页数减一才能省略  
**注意事项**  
代码中出现的`@click=$emit('getPageNo')`是组件外需要传入的一个自定义事件，当触发按钮的时候，应该把组件内部的当前值传递给外面的组件，外面的组件再将需要展示哪一页的页数传递给服务器，并在浏览器展示对应的数据  
## 六、路由组件开发问题汇总
### Home组件
常规的开发流程，派发`action`获取数据，动态的展示数据，没有别的业务逻辑，这方面有问题可以参考前面的非路由组件开发问题汇总  
### Search组件
Search组件的参数是从Home的组件当中传递过来的，有依靠路由传递，还有组件内定义的数据，所以在组件挂载发请求之前，应该先整理好这些请求参数，然后发请求获取数据进行展示，所以这里用到了一个生命周期钩子`beforeMount`，在该生命周期钩子当中运用ES6的语法，将所有的请求合并  
```javascript
    Object.assign(this.searchParams,this.$route.query,this.$route.params)
```  
其中searchParams应该先在data中书写  
```javascript
    data() {
        return {
        // 带给服务器的参数
        searchParams: {
            // 一级分类的id
            category1Id: "",
            // 二级分类的id
            category2Id: "",
            // 三级分类的id
            category3Id: "",
            // 分类的名字
            categoryName: "",
            // 用户输入的关键字
            keyword: "",
            // 排序：初始值应该是综合|降序
            order: "1:desc",
            // 分页器用的参数
            pageNo: 1,
            // 代表的是每一页展示数据的个数
            pageSize: 10,
            // 平台售卖属性操作的参数
            props: [],
            // 品牌
            trademark: "",
        },
    };
    },
```  
定义好之后，下一步就应该是发请求，在`Search`组件当中，有很多地方都需要更改数据发送请求，所以我们将发请求封装成一个函数，在后面的操作当中如果需要更改参数发请求直接调用方法即可  
```javascript
    methods: {
        // 向服务器发请求获取search模块数据（根据参数的不同返回不同的数据进行展示）
        // 把这次请求封装成一个函数，当你需要调用的时候调用即可
        getData() {
            this.$store.dispatch("getSearchList",this.searchParams);
        }
    }
```  
接下来就可以在`mounted`生命周期函数中调用`getData()`获取到数据了，然后就是`vuex`的三连环。  
#### Search组件主要业务逻辑分析
> SearchSelector子组件的开发

在`Search`页面中，把上方的参数菜单栏拆分成了一个子组件，因为刚刚的数据已经存储在`vuex`中，可以在该组件中，直接获取到`vuex`中的数据，并将相应的数据进行一个动态展示。现在，父组件`Search`需要接收来自子组件的的数据，`SearchSelector`组件需要告诉`Search`组件，用户点击了哪一个品牌，哪一个售卖的参数，所以这里采用了自定义事件的方式进行子向父传递数据。在`Search`组件中，给`SearchSelector`绑定了两个自定义事件。  
```javascript
    <SearchSelector @trademarkInfo="trademarkInfo" @attrInfo="attrInfo"/>
    methods:{
        // 自定义事件的回调
        trademarkInfo(trademark){
            // 整理品牌字段的参数 "ID:品牌名称"
            this.searchParams.trademark=`${trademark.tmId}:${trademark.tmName}`
            // 再次发送请求获取search模块列表数据进行展示
            this.getData()
        },
        // 收集平台属性地方的回调
        attrInfo(attrs,attrValue){
            // ["属性ID:属性值:属性名"]
            // 参数格式整理好
            let props=`${attrs.attrId}:${attrValue}:${attrs.attrName}`
            // 数组去重
            if(this.searchParams.props.indexOf(props)==-1){
                this.searchParams.props.push(props)
            }      
            // 再次发请求
            this.getData()
        }
    }
```  
在*SearchSelector*当中触发的事件，并且传入参数  
```javascript
    methods:{
        // 品牌的事件处理函数
        tradeMarkHandler(trademark){
            // 点击了品牌（苹果），还是需要整理参数，向服务器发送请求获取相应的数据进行展示
            // 在哪个组件中发请求?父组件
            // 因为父组件中searchParams参数是带给服务器参数，子组件把你点击的品牌信息，需要给父组件传递过去---自定义事件
            this.$emit('trademarkInfo',trademark)
        },
        // 平台售卖属性值的点击事件
        attrInfo(attrs,attrValue){
            // ["属性ID:属性值:属性名"]
            this.$emit('attrInfo',attrs,attrValue)
        }
    }
```  
*SearchSelector*组件当中触发了事件，传递了参数，其中trademark表示品牌的名称，attrs表示整个数据的信息，attrValue表示点击的是哪一个。*Search*组件在接收以后，将参数按照服务器所需要的格式进行打包，然后都需要重新发送请求  
> Search页面使用TypeNav和搜索该怎么实现

TypeNav组件传递的参数是query参数，query参数会改变路由的信息，所以正确的做法应该是在Search组件当中，对路由进行一个监听，如果路由发生了改变，就应该进行数据的重新获取，所以这里需要使用watch对路由进行一个监听。  
```javascript
    watch:{
        // 监听路由的信息是否发生变化，如果发生变化，再次发起请求
        $route(newValue,oldValue){
            // 再次发请求之前整理带给服务器参数
            Object.assign(this.searchParams,this.$route.query,this.$route.params)
            // 再次发起ajax请求
            this.getData()
            // 每一次请求完毕，应该把相应的1、2、3级分类的id置空，让他接收下一次相应的1、2、3id
            // 分类的名字与关键字不用清理：因为每一次路由发生变化的时候，都会给他赋予新的数据
            this.searchParams.category1Id=undefined
            this.searchParams.category2Id=undefined
            this.searchParams.category3Id=undefined
        }
    }
```  
如果路由发生了变化，watch就会执行，所以还是一样，先把更新的参数进行整理，打包在发请求给服务器，但是这里需要注意，因为点击TypeNav的各级菜单的时候，都会传递参数到searchParams当中，如果刚开始点击的是一级菜单的，传递的就是category1Id，如果不进行清理，就会导致下次用户点击二三级菜单的时候，一级菜单的参数还在，就会导致参数传递的错误，所以要将参数置空  
> 面包屑的实现

首先，需要在结构当中添加面包屑，并加上条件渲染，面包屑的展示必须要有searchParams中有这个参数再进行展示，需要注意品牌的数据和售卖属性的数据，是在子组件传递过来之后打包后的数据，数据的格式与我们要展示的格式不同，所以需要使用数组的方法split进行裁剪后再展示    
```html
    <ul class="fl sui-tag">
        <!-- 分类的面包屑 -->
        <li class="with-x" v-if="searchParams.categoryName">{{searchParams.categoryName}}<i @click="removeCategoryName">×</i></li>
        <!-- 关键字的面包屑 -->
        <li class="with-x" v-if="searchParams.keyword">{{searchParams.keyword}}<i @click="removeKeyWord">×</i></li>
        <!-- 品牌的面包屑 -->
        <li class="with-x" v-if="searchParams.trademark">{{searchParams.trademark.split(':')[1]}}<i @click="removeTradeMark">×</i></li>
        <!-- 平台的售卖的属性值展示 -->
        <li class="with-x" v-for="(attrValue,index) in searchParams.props" :key="index">{{attrValue.split(':')[1]}}<i @click="removeAttr(index)">×</i></li>
    </ul>
```  
并且需要给每一个面包屑绑定一个隐藏，清除该面包屑的回调  
```javascript
    methods:{
        // 删除分类的名字
        removeCategoryName(){
            // 把带给服务器的参数置空了，还需要向服务器发送请求
            // 带给服务器参数说明（可有可无的）：如果属性值为空的字符串还是会把相应的字段带给服务器
            // 但是你把相应的字段变为undefined，当前这个字段不会带给服务器
            this.searchParams.categoryName=undefined
            this.searchParams.category1Id=undefined
            this.searchParams.category2Id=undefined
            this.searchParams.category3Id=undefined
            this.getData()
            // 地址栏也需要改：进行路由跳转(现在的路由跳转只是跳转到自己这里)
            // 严谨：本意是删除query，如果路径当中出现params不应该删除，路由跳转的时候应该带着
            if(this.$route.params){
                this.$router.push({name:'search',params:this.$route.params})
            }
        },
         // 删除关键字
        removeKeyWord(){
            // 给服务器带的参数searchParams的keyword参数置空
            this.searchParams.keyword=undefined
            // 再次发送请求
            this.getData()
            // 通知兄弟组件header清除关键字
            this.$bus.$emit("clear")
            // 进行路由的跳转
             if(this.$route.query){
                this.$router.push({name:'search',query:this.$route.query})
            }
        },
        // 删除品牌的信息
        removeTradeMark(){
            // 将品牌信息置空
            this.searchParams.trademark=undefined
            // 再次发送请求
            this.getData()
        },
        // 删除售卖的属性
        removeAttr(index){
            // 整理参数
            this.searchParams.props.splice(index,1)
            // 再次发请求
            this.getData()
        }
    }
```  

> 综合与价格的升降序

首先要知道排序的参数代表的是什么意思，在传递参数的时候，需要传递`order`参数`order: "1:desc"`，其中这里的1代表的是综合，2代表的是价格，desc代表的是降序，asc代表的是升序。可以通过计算属性，计算出来各种结果  
```javascript
    computed: {
        isOne(){
        return this.searchParams.order.indexOf('1')!=-1
        },
        isTwo(){
        return this.searchParams.order.indexOf('2')!=-1
        },
        isAsc(){
        return this.searchParams.order.indexOf('asc')!=-1
        },
        isDesc(){
        return this.searchParams.order.indexOf('desc')!=-1
        },
    }
```  
indexOf方法是去查找字符串里有没有符合条件的，如果没有找到就会返回-1，所以这里的返回值都表示已经找到了对应的量才会返回，可以在模板中添加条件渲染，并且绑定点击事件  
```html
    <li :class="{active:isOne}" @click="changeOrder('1')">
        <a>综合<span v-show="isOne&&isAsc">↑</span><span v-show="isOne&&isDesc">↓</span></a>
    </li>
    <li :class="{active:isTwo}" @click="changeOrder('2')">
        <a>价格<span v-show="isTwo&&isAsc">↑</span><span v-show="isTwo&&isDesc">↓</span></a>
    </li>
```  
绑定的事件需要传递参数，这样下面写回调函数的时候，才能知道点击的是哪一个  
```javascript
    // 排序的操作
    changeOrder(flag){
        // flag是一个形参：它是一个标记，代表用户点击的是综合（1）还是价格（2）[用户点击的时候传递过来的]
        let originOrder=this.searchParams.order
        // 这里获取的是最开始的状态
        let originFlag=this.searchParams.order.split(':')[0]
        let originSort=this.searchParams.order.split(':')[1]
        // 准备一个新的order属性值
        let newOrder = ''
        // 这个语句我能确定点击的一定是综合
        if(flag==originFlag){
            newOrder=`${originFlag}:${originSort=='desc'?"asc":"desc"}`
        }else{
            //点击的是价格
            newOrder=`${flag}:${'desc'}`
        }
        // 将新的order赋予searchParams
        this.searchParams.order=newOrder
        // 再次发请求
        this.getData()
    }
```  
### Detail组件
该组件是商品的详情页，静态页面搭建完毕之后就是向服务器发请求获取数据进行页面的动态展示，使用的就是vuex，如果还不知道怎么获取请求可以参考前面的内容，主要说明的组件一些业务逻辑的实现
#### Detail主要业务逻辑分析
> 商品轮播图的实现

轮播图运用的还是swiper5实现的，它是单独的一个组件，所用到的图片需要进行组件通信传递，是Detail使用props方式进行传递的。轮播图的动态展示，还是使用了监听属性和nextTick相互配合使用的，保证了swiper能够获取到带有数据的DOM结构，并对轮播图进行了一些配置，具体相关的轮播图配置可以参考swiper的[官方网站](https://www.swiper.com.cn/)  
由于图片展示区域的大图和下方的可以点击的轮播小图是不一样的，所以需要向兄弟组件传递当前的图片的索引，所以这里使用了全局事件总线$bus向兄弟组件传递当前图片的index  
```javascript
    changeCurrentIndex(index){
        // 修改响应式数据
        this.currentIndex=index
        // 通知兄弟组件：当前的索引值为几
        this.$bus.$emit('getIndex',this.currentIndex)
    }
```
> 放大镜的实现

实现放大镜其实就是在修改定位的top值和left值，在该组件的实现中，首先运用了ref来获取DOM元素。该组件中主要就是需要计算出偏移量，所以给大的容器先绑定一个鼠标移入事件mousemove，然后给事件绑定回调函数  
```javascript
    handler(event){
        let mask=this.$refs.mask
        let big=this.$refs.big
        let left=event.offsetX-mask.offsetWidth/2
        // console.log(event.offsetX-mask.offsetWidth/2)
        // console.log(mask.offsetWidth/2)
        let top=event.offsetY-mask.offsetHeight/2
        // 约束范围
        if(left<=0) left=0
        if(left>=mask.offsetWidth) left=mask.offsetWidth
        if(top<=0) top=0 
        if(top>=mask.offsetHeight) top=mask.offsetHeight
        // 修改元素的top|left值
        mask.style.left=left+'px'
        mask.style.top=top+'px'
        big.style.left=-2*left+'px'
        big.style.top=-2*top+'px'
      }
    }
```  
其中，使用offsetX获取了鼠标到边框的距离，然后又通过mask.offsetWidth获取到了遮罩层的总长度，鼠标到边框的距离，减去遮罩层总长度的一半就等于遮罩层到边框的距离，都能够知道遮罩层在图片当中移动了多少距离，然后就修改大图移动的距离，就能达到放大镜移动放大的效果。但是，遮罩层的移动，要将它限制在框里面，所以需要进行范围约束
> 选择物品参数的实现

给遍历出来的数据绑定一个点击事件，然后配置其回调函数，这里主要需要用到的就是排他思想。  
```javascript
    // 产品的售卖属性值切换高亮
    changeActive(saleAttrValue, arr) {
        // 遍历全部的售卖属性值isCheacked为零就没有高亮了
        arr.forEach((item) => {
            item.isChecked = "0";
        });
        // 点击的那个售卖属性值
        saleAttrValue.isChecked = "1";
    },
```  
isChecked是服务器传递的数据，如果为0表示不选中，如果为1表示选中，所以利用排他思想，就是点击的时候，将其他所有的售卖属性都变成0，只让点击的那个属性变成1
> 输入框输入，点击修改物品数量

在输入框中，应该先要有一个固定值，以用户角度而言，既然点进入详情页，购买的数量至少为1，所以，我们可以定义一个常量1，在data属性保存，并给input进行v-model双向绑定，并且要给两个按钮，进行点击事件的绑定，可以直接在模板字符串中书写简单的运算，让点击按钮的时候，data中的数据自增或者自减。同时要考虑一些问题，例如文本框的输入的内容，应该只能是数字，如果用户输入其他内容，则需要进行一些限制  
这里给文本框绑定了一个change事件，当失去焦点的时候，就会执行这个事件的回调，所以，接下来就来定义这个回调  
```javascript
    changeSkuNum(event) {
        // 用户输入进来的文本 *1
        let value = event.target.value * 1;
        // 如果用户输入进来的非法，出现NaN或者小于1
        if (isNaN(value) || value < 1) {
            this.skuNum = 1;
        } else {
            // 正常大于1，但是必须要是整数
            this.skuNum = parseInt(value);
        }
    }
```  
> 加入购物车路由跳转，并发送请求

当用户点击加入购物车的时候，应该进行路由的跳转，并且向服务器发起请求，但是在下一个路由组件当中，仍然需要使用到该详情页的数据，所以要考虑如果携带数据进行跳转，一些简单的参数，例如用户购买产品的数量，就采用了query参数进行传递，剩下用户选中的产品的参数购买物品的信息，这里采用了会话存储的方式进行传递，要明确一点，不管是会话存储还是本地存储，存储的形式一定要是字符串，所以这里还需要用到JSON的方法转成字符串，所以先给元素绑定一个点击事件，并配置它的回调函数  
```javascript
    async addShopcar() {
        // 1.发请求---将产品加入到数据库（通知服务器）
        /* 
            当前这里是派发了一个action，也向服务器发请求，判断加入购物车是成功还是失败 
            this.$store.dispatch('addOrUpdateShopCart',{skuId:this.$route.params.skuid,skuNum:this.skuNum})
            上面这行代码说白了：调用仓库中的addOrUpdateShopCart，这个方法加上async，返回的一定是一个Promise
            要么成功，要么失败
        */
        try {
            await this.$store.dispatch("addOrUpdateShopCart", {
            skuId: this.$route.params.skuid,
            skuNum: this.skuNum,
            });
            // 路由跳转
            // 在路由跳转的时候还需要将产品的信息带给下一级的路由组件
            // 下面这种手段路由跳转以及传递参数可以
            // 一些简单的数据skuNum，通过query形式给路由组件传递过去
            // 产品信息的数据【比较复杂：skuInfo】，通过会话存储（不持久化，会话结束数据消失）
            // 不管是本地存储|会话存储，一般存的是字符串
            sessionStorage.setItem('SKUINFO',JSON.stringify(this.skuInfo))
            this.$router.push({name:'addcartsuccess',query:{skuNum:this.skuNum}})
        } catch (error) {
            alert(error.message);
        }
        // 2.服务器存储成功---进行路由跳转传递参数
        // 3.失败，给用户进行提示
    }
```  
skuInfo就是购买物品的详细信息，await表示等待请求的成功结果，成功返回的是一个Promise，await的使用需要配合async，所以需要在函数的前面加上async。  
trycatch表示的是如果成功则执行try里面的，如果失败则返回失败的原因  

### ShopCart组件
开发流程基本和之前的组件差别不大，在静态页面开发完毕之后，发请求，将数据存储于vuex仓库当中，并在组件中进行动态数据的展示，但是，获取购物车信息的请求在这里需要进行一下封装，在其他命令执行完毕之后，可能需要用到刷新购物车的数据。在组件挂载完毕之后，需要进行一次请求    
```javascript
    // 获取个人购物车
    getData() {
      this.$store.dispatch("getCartList");
    }
```  
这里需要注意，正常来说访问购物车，添加进购物车应该需要登录才能让数据库进行数据的存储，所以这里就需要向服务器传递一个请求头，表示用户如果没有登录的时候，采用的就是一个游客身份访问的网站，可以保存商品进入购物车。在此我们需要在请求拦截器中配置请求头，我们在utils文件中创建一个文件专门用来生成发送给后端服务器的用户身份标识uuid，注意使用uuid之前需要npm下载    
```javascript
    import {v4 as uuidv4} from 'uuid'
    // 要生成一个随机字符串，且每次执行不能发生变化，游客身份持久存储
    export const getUUID=()=>{
        // 先从本地存储获取uuid（看一下本地存储里面是否有）
        let uuid_token =localStorage.getItem('UUIDTOKEN')
        // 如果没有
        if(!uuid_token){
            // 我生成游客临时身份
            uuid_token=uuidv4()
            // 本地存储存储一次
            localStorage.setItem('UUIDTOKEN',uuid_token)
        }
        // 切记有返回值，没有返回值undefined
        return uuid_token
    }
```  
然后就是配置请求头
```javascript
    requests.interceptors.request.use((config)=>{
        // config：配置对象，对象里面有一个属性很重要，header请求头
        // 进度条开始动
        if(store.state.detail.uuid_token){
            // 请求头添加一个字段（userTempId）：和后台老师商量好了
            config.headers.userTempId=store.state.detail.uuid_token
        }
    }
```
#### ShopCart组件主要业务逻辑分析
> 修改产品的个数

首先，需要给模板字符串当中的元素绑定一个点击事件，还有给文本框绑定一个change事件，在绑定事件的时候，需要传递一些参数，第一个参数就是给点击的元素打一个标识，然后给点击+的按钮传入一个1，点击-的按钮传入一个-1，input需要获取input框当中的值并传入，最后一个参数就是表示当前点击的是哪一个，将当前点击的这个元素的属性传递给回调当中  
```html
    <!-- 添加 -->
    <a @click="handler('minus', -1, cart)">+</a>
    <!-- 文本框 -->
    <input type="text" @change="handler('change', $event.target.value * 1, cart)"/>
    <!-- 减少 -->
    <a @click="handler('add', 1, cart)">-</a>
```  
在mothods中配置回调，运用switch和传入的参数进行比对，如果符合传入的名字，就对数量进行赋值，向服务器传递参数，唯一需要注意的就是input框，需要进行输入的限制，和前面的商品详情组件类似，在这里的按钮，使用了前面的防抖技术进行了点击按钮的防抖。在修改完数据之后，记得要重新发起请求    
```javascript
    // 修改某一个产品的个数
    // 引入lodash.throttle进行防抖，连续点击按钮只保留最后一次
    handler: debounce(async function (type, disNum, cart) {
        // type：为了区分三个元素
        // disNum形参：+ 变化量（1） -变化量（-1） input最终的个数（并不是变化量）
        // cart：哪一个产品【身上有id】
        // 向服务器发请求，修改数量
        switch (type) {
            // 加号
            case "add":
            // 带给服务器变化的量
            disNum = 1;
            break;
            case "minus":
            // 判断产品的个数大于1，才可以传递给服务器-1
            // 如果出现产品的个数小于等于1，传递给服务器个数0（原封不动）
            disNum = cart.skuNum > 1 ? -1 : 0;
            break;
            case "change":
            // 用户输入进来的最终量，如果是非法的（带有汉字|出现负数），带给服务器数字零
            if (isNaN(disNum) || disNum < 1) {
                disNum = 0;
            } else {
                // 属于正常情况（小数：取整），带给服务器变化的量 用户输入进来的 - 产品的起始个数
                disNum = parseInt(disNum) - cart.skuNum;
            }
            // disNum=(isNaN(disNum)||disNum<1)?0:parseInt(disNum)-cart.skuNum
            break;
        }
        // 派发actions
        try {
            // 代表修改成功
            await this.$store.dispatch("addOrUpdateShopCart", {
            skuId: cart.skuId,
            skuNum: disNum,
            });
            // 再一次获取服务器最新的数据进行展示
            this.getData();
        } catch (error) {}
    }, 500),
```
> 修改产品的勾选状态

修改勾选状态需要向服务器发起请求，在数据库进行修改。先给勾选框绑定一个点击事件，点击勾选框的时候触发回调  
```javascript
    // 修改某个产品的勾选状态
    async updateChecked(cart, event) {
        try {
            await this.$store.dispatch("updateCheackedById", {
            skuId: cart.skuId,
            isChecked: +event.target.checked,
            });
            // 如果请求成功，再次获取服务器数据（购物车）
            this.getData();
        } catch (error) {
            alert(error.message);
        }
    },
```  
这里因为不需要将服务器返回的数据存储进vuex当中，所以我们只需要等待请求返回的结果即可，如果请求成功，则会执行try里面的函数，需要注意的就是请求成功之后，需要再次获取购物车的数据，才能动态刷新页面
> 删除某一个商品

绑定单击事件，点击的时候触发回调，向服务器发请求即可
> 删除全部选中的产品

首先还是绑定点击事件，并且配置一个回调发请求  
```javascript
    // 删除全部选中的商品
    // 这个回调函数咱们没办法收集到一些有用的数据
    async deleteAllCheckedCart() {
        try {
            // 派发一个actions
            await this.$store.dispatch("deleteAllCheckedCart");
            // 删除成功之后，再次发送请求获取购物车新的数据
            this.getData();
        } catch (error) {
            alert(error.message);
        }
    },
```  
但是在这里回调函数中，并没有办法收集到一些有用的数据。在仓库当中，我们应该向服务器发起请求，但是这里我们是调用了删除某一个产品的请求事件  
```javascript
    // 删除全部勾选的产品
    deleteAllCheckedCart({ dispatch, getters }) {
        // context：小仓库，commit【提交mutations修改state】 getters【计算属性】 dispatch【派发action】 state【当前仓库数据】
        // 获取购物车中全部的产品（是一个数组）
        let promiseAll = []
        getters.cartList.cartInfoList.forEach(item => {
            let promise = item.isChecked == 1 ? dispatch('deleteCartListBySkuId', item.skuId) : ''
            // 将每一次返回的Promise添加到数组中
            promiseAll.push(promise)
        })
        // 只要全部的promise都成功，返回的结果即为成功
        // 如果有一个失败，返回结果即为失败
        return Promise.all(promiseAll)
    },
```  
我们先获取到了购物车中所有的产品数据，并对他们进行了遍历，如果满足条件的，调用删除单个产品的请求直接删除掉，这样就能够实现删除全部选中的产品的业务
